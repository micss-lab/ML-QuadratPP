
/****************************************************************/
/*                                                              */
/*  !!! THIS FILE IS AUTOMATICALLY GENERATED - DO NOT EDIT  !!! */
/*                                                              */
/****************************************************************/

import "MQTTEchoTestClientJavaScript.thingml"



thing TestMQTTReceiverPort_JavaScriptMqttJson_Impl includes TestMQTTReceiverPort, MQTTAdapterMsgs 
{
	
	required port jsmqtt 
	@sync_send "true"
	{
		sends mqtt_publish, mqtt_subscribe
		receives mqtt_message, mqtt_connected
	}
	
	readonly property mqtt_topic_name : String  = "receiver"
	
	
	function subscribe_for_message(msg_name : String) do
		readonly var topic : String = mqtt_topic_name + "/" + msg_name
		jsmqtt!mqtt_subscribe(topic)
	end
	
	function publish_message(msg_name : String, payload: Buffer, size : UInt32) do
		readonly var topic : String = mqtt_topic_name + "/" + msg_name
		jsmqtt!mqtt_publish(topic, payload, size)
	end
	
	
	function mqtt_subscribe() do
		
	end
	
	function mqtt_parsemsg(topic : String, payload : Buffer, len : UInt32) : Boolean do
		`try {
			let json = JSON.parse(` & payload & `);
			let split = ` & topic & `.split('/');`
			`if (split.length != 2)` return false // This is not a valid message
			
			readonly var portname : String = `split[0]` as String
			readonly var msgname : String = `split[1]` as String
			
			if (portname != mqtt_topic_name) return false
			
			`switch (`&msgname&`) {  
				
				default: break;
			}`
			
		`} catch(err) {`
			errorln "Unable to parse message invalid message from topic ", topic, ". Payload: ", payload ," Message Dropped."
			errorln `err`
		`}`
		return false
	end
	
	
	statechart PosixMQTTJSonSC init Running {
	
		internal event jsmqtt?mqtt_connected action mqtt_subscribe()
		internal event m : jsmqtt?mqtt_message action mqtt_parsemsg(m.topic, m.payload, m.size)

				internal event e:receiver?no_parameters action do
			// Sending for receiver!no_parameters
			`let json = {};
			let payload = JSON.stringify(json);`
			publish_message("no_parameters", `payload` as Buffer, `payload.length` as UInt32)
		end

		internal event e:receiver?some_numbers action do
			// Sending for receiver!some_numbers
			`let json = {};
			json.i8 = ` & e.i8 & `;
			json.ui8 = ` & e.ui8 & `;
			json.i = ` & e.i & `;
			json.ui = ` & e.ui & `;
			json.d = ` & e.d & `;
			json.l = ` & e.l & `;
			let payload = JSON.stringify(json);`
			publish_message("some_numbers", `payload` as Buffer, `payload.length` as UInt32)
		end

		internal event e:receiver?some_strings action do
			// Sending for receiver!some_strings
			`let json = {};
			json.c = ` & e.c & `;
			json.str = ` & e.str & `;
			let payload = JSON.stringify(json);`
			publish_message("some_strings", `payload` as Buffer, `payload.length` as UInt32)
		end

		internal event e:receiver?some_bytes action do
			// Sending for receiver!some_bytes
			`let json = {};
			json.b1 = ` & e.b1 & `;
			json.b2 = ` & e.b2 & `;
			let payload = JSON.stringify(json);`
			publish_message("some_bytes", `payload` as Buffer, `payload.length` as UInt32)
		end

		internal event e:receiver?some_enum action do
			// Sending for receiver!some_enum
			`let json = {};
			json.d0 = ` & e.d0 & `;
			json.d1 = ` & e.d1 & `;
			let payload = JSON.stringify(json);`
			publish_message("some_enum", `payload` as Buffer, `payload.length` as UInt32)
		end



		state Running {}
		
	}
}

